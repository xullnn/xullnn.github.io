<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Algorithms 101 - 3 - recursion</title>
<!-- The styles.css referenced here is generated by Jekyll from the styles.scss -->
    <link rel="stylesheet" href="/assets/css/styles.css">
  </head>
  <body>
      <div class="post">

  <!-- <nav>
  
    <a href="/" >
      Home
    </a>
  
    <a href="/blog.html" >
      Blog
    </a>
  
    <a href="/photography.html" >
      Photography
    </a>
  
    <a href="/me.html" >
      Me
    </a>
  
</nav> -->


<!-- <div class="bar_nav">
  <p>Home</p>
  <p>Portfolio</p>
  <p>Blog</p>
  <p>Me</p>
</div> -->


<div class="bar_nav">
  
    
    <p ><a href="/">Home</a></p>
  
    
    <p  class="current" ><a href="/blog.html">Blog</a></p>
  
    
    <p ><a href="/photography.html">Photography</a></p>
  
    
    <p ><a href="/me.html">Me</a></p>
  
</div>

  <h1>Algorithms 101 - 3 - recursion</h1>
  <p>25 Apr 2018</p>


  <p><em>算法入门笔记，基于《Grokking Algorithms: An illustrated guide for programmers and other curious people》这本书的内容</em></p>

<h3 id="主要内容">主要内容</h3>

<ul>
  <li>Recursion is when a function calls itself.    <br />
递归是一种会call到自身的函数</li>
  <li>Every recursive function has two cases: the base case and the recursive case.    <br />
每一个递归函数都有两种case: base case 和 递归case</li>
  <li>A stack has two operations: push and pop.   <br />
针对堆栈的操作有两种： push 和 pop</li>
  <li>All function calls go onto the call stack.
所有函数呼叫都会在这个呼叫的 call stack 上</li>
  <li>The call stack can get very large, which takes up a lot of memory.   <br />
当call stack 变得非常长的时候，会占用很多的内存</li>
</ul>

<hr />

<p>Recursion中文译作递归。是很多算法中都会用到的编程技术。</p>

<blockquote>
  <p>Many important algorithms use recursion, so it’s important to understand the concept.</p>
</blockquote>

<hr />

<h4 id="1-recursion-is-when-a-function-calls-itself">1 Recursion is when a function calls itself.</h4>

<p>Recursion function/method 是指那些会在自身内部再次call到方法本身的 function/method.</p>

<p>书中给的从嵌套箱子中找钥匙的例子有点让人疑惑。直接用一个简单的代码(用ruby)示例说明：</p>

<div class="language-ruby highlighter-coderay"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
<a href="#n3" name="n3">3</a>
<a href="#n4" name="n4">4</a>
<strong><a href="#n5" name="n5">5</a></strong>
<a href="#n6" name="n6">6</a>
<a href="#n7" name="n7">7</a>
<a href="#n8" name="n8">8</a>
<a href="#n9" name="n9">9</a>
</pre></td>
  <td class="code"><pre><span style="color:#080;font-weight:bold">def</span> <span style="color:#06B;font-weight:bold">recursive_sum</span>(list)
  <span style="color:#080;font-weight:bold">if</span> list == []
    <span style="color:#080;font-weight:bold">return</span> <span style="color:#00D">0</span>
  <span style="color:#080;font-weight:bold">else</span>
    <span style="color:#080;font-weight:bold">return</span> list.shift + recursive_sum(list) <span style="color:#777"># 这里就call回到自己本身</span>
  <span style="color:#080;font-weight:bold">end</span>
<span style="color:#080;font-weight:bold">end</span>

puts recursive_sum [<span style="color:#00D">1</span>,<span style="color:#00D">2</span>,<span style="color:#00D">3</span>,<span style="color:#00D">4</span>]
</pre></td>
</tr></table>
</div>

<p>拆开一步一步看：</p>

<p>recursive_sum [1,2,3,4] (第1步)</p>
<ul>
  <li>else: return 1 + recursive_sum([2,3,4]) (return 并没有完成，挂起，进入recursion第2步)
    <ul>
      <li>recursive_sum [2,3,4]
        <ul>
          <li>else: return 2 + recursive_sum([3,4]) (return 并没有完成，挂起，进入recursion第3步)
            <ul>
              <li>recursive_sum [3,4]
                <ul>
                  <li>else: return 3 + recursive_sum([4]) (return 并没有完成，挂起，进入recursion第4步)
                    <ul>
                      <li>recursive_sum [4]
                        <ul>
                          <li>else: return 4 + recursive_sum([]) (return 并没有完成，挂起，进入recursion第5步)
                            <ul>
                              <li>recursive_sum []
                                <ul>
                                  <li>if: return 0, 这一步 return 完成，上一步第5步中被挂起的 <code>recursive_sum([])</code> 返回0</li>
                                </ul>
                              </li>
                              <li>第5步中 return (4 + 0) = 4, 第4步中的 <code>recursive_sum([4])</code> 拿到结果 4</li>
                            </ul>
                          </li>
                          <li>第4步中 return (3 + 4) = 1, 第3步中的 <code>recursive_sum([3,4])</code> 拿到结果 7</li>
                        </ul>
                      </li>
                      <li>第3步中 return (2 + 7) = 1, 第2步中的 <code>recursive_sum([2,3,4])</code> 拿到结果 9</li>
                    </ul>
                  </li>
                  <li>第2步中 return (1 + 9) = 10, 第1步中的 <code>recursive_sum([1,2,3,4])</code> 拿到结果 10</li>
                </ul>
              </li>
              <li>第1步中 else 分支的 return <strong>拿到最终结果 10</strong>， 退出function。</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h4 id="2-every-recursive-function-has-two-cases-the-base-case-and-the-recursive-case">2 Every recursive function has two cases: the base case and the recursive case.</h4>

<p><strong>base case：</strong> 即设定好的让 recursion 能在最后停下来的条件。上面例子中就是 if 分支对应的代码</p>

<p><strong>recursive case:</strong> 即设定好的让recursion继续循环下去的条件。上面例子中即是 else 分支对应的代码，能让recursion逐渐收拢或说base case靠近。</p>

<p><a href="https://en.wikipedia.org/wiki/Recursion#base_case">wikipedia中recursion的定义</a></p>

<blockquote>
  <p>In mathematics and computer science, a class of objects or methods exhibit recursive behavior when they can be defined by two properties:  <br />
A simple <strong>base case</strong> (or cases)—a terminating scenario that does not use recursion to produce an answer   <br />
（recursive case）A set of rules that reduce all other cases toward the base case</p>
</blockquote>

<p>base case对应的中文理解最好不是’基础条件’或’基本条件’, 我倾向于理解为’触底条件’，这样容器理解他实际是一个临界条件/状态，是stack堆到最高处即将开始回归的点。</p>

<h4 id="3-the-call-stack-in-recursion">3 The call stack in Recursion</h4>

<p>可以使用视觉化的方式来理解call stack。将其想象为一个不断累加的积木，来看上面代码实例的call stack结构。</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">第1步</th>
      <th style="text-align: center">第2步</th>
      <th style="text-align: center">第3步</th>
      <th style="text-align: center">第4步</th>
      <th style="text-align: center">第5步</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
      <td style="text-align: center">recursive_sum []</td>
    </tr>
    <tr>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
      <td style="text-align: center">recursive_sum [4]</td>
      <td style="text-align: center">recursive_sum [4]</td>
    </tr>
    <tr>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
      <td style="text-align: center">recursive_sum [3,4]</td>
      <td style="text-align: center">recursive_sum [3,4]</td>
      <td style="text-align: center">recursive_sum [3,4]</td>
    </tr>
    <tr>
      <td style="text-align: center"> </td>
      <td style="text-align: center">recursive_sum [2,3,4]</td>
      <td style="text-align: center">recursive_sum [2,3,4]</td>
      <td style="text-align: center">recursive_sum [2,3,4]</td>
      <td style="text-align: center">recursive_sum [2,3,4]</td>
    </tr>
    <tr>
      <td style="text-align: center">recursive_sum [1,2,3,4]</td>
      <td style="text-align: center">recursive_sum [1,2,3,4]</td>
      <td style="text-align: center">recursive_sum [1,2,3,4]</td>
      <td style="text-align: center">recursive_sum [1,2,3,4]</td>
      <td style="text-align: center">recursive_sum [1,2,3,4]</td>
    </tr>
  </tbody>
</table>

<p>可以看到从第一层开始，call stack逐层堆叠，其中每一层存在的call stack都说明这个function/method还未完成，处于挂起状态。</p>

<p>在第5步时触及 base case 后，call stack 不会再向上堆叠。而是向下回归，逐步完成每一步被挂起的 function/method。就像把积木一个一个逐层拿下来。也就是call stack最上层的funciton/method执行完之后，下面的才能相继得以完成。</p>

<p>wikipedia 上 stack 的示意图</p>

<p><img src="https://s3-ap-southeast-1.amazonaws.com/image-for-articles/image-bucket-1/Lifo_stack.png" alt="" /></p>

<p><strong>需要注意的是在整个 call stack 中，function/method 之间可以传递对象</strong>， 上面例子中则是用于计算的那个 array</p>

<blockquote>
  <p>This is the big idea behind this section: when you call a function from another function, the calling function is paused in a partially completed state. All the values of the variables for that function are still stored in memory.”</p>
</blockquote>

<h4 id="4-stack-的得与失">4 stack 的得与失</h4>

<p>使用 stack 的一个风险是，可能会用掉很多的内存，当stack堆叠层数很多时，每一步都被挂起，每一步都要存储信息，这就可能导致占用很多内存。两种解决方法：</p>

<p>1 使用 loop 而不用 recursive 的写法</p>

<p>2 使用 <code>trail recursion</code> 方法，这个方法超出本书讨论范围，而且只能在某些语言中使用。</p>

<p>** Loop 与 Recursion **</p>

<p>上面array求和的例子使用loop也可以做到：</p>

<div class="language-ruby highlighter-coderay"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
<a href="#n3" name="n3">3</a>
<a href="#n4" name="n4">4</a>
<strong><a href="#n5" name="n5">5</a></strong>
<a href="#n6" name="n6">6</a>
<a href="#n7" name="n7">7</a>
<a href="#n8" name="n8">8</a>
<a href="#n9" name="n9">9</a>
</pre></td>
  <td class="code"><pre><span style="color:#080;font-weight:bold">def</span> <span style="color:#06B;font-weight:bold">loop_sum</span>(list)
  acc = <span style="color:#00D">0</span>
  i = <span style="color:#00D">0</span>
  <span style="color:#080;font-weight:bold">while</span> i &lt; list.length
    acc += list[i]
    i += <span style="color:#00D">1</span>
  <span style="color:#080;font-weight:bold">end</span>
  <span style="color:#080;font-weight:bold">return</span> acc
<span style="color:#080;font-weight:bold">end</span>
</pre></td>
</tr></table>
</div>

<p>这引出了什么情况使用 loop 什么情况使用 recursion 这个问题。实际情况是处理相同的任务loop可能更节省内存（变量一直在动态变化，而不是每个循环都要存，也不会有多个function/method挂起），recursive fucntion/method 比较易读。书上给出了一个 Stackoverflow 上的答案。</p>

<p>https://stackoverflow.com/questions/72209/recursion-or-iteration/72694</p>

<blockquote>
  <p>Loops may achieve a performance gain for your program. Recursion may achieve a performance gain for your programmer. Choose which is more important in your situation!</p>
</blockquote>

<p>很多重要的算法使用 recursion 所以理解他的概念很重要 – Recursion is when a function calls itself.</p>

<h4 id="5-all-function-calls-go-onto-the-call-stack">5 All function calls go onto the call stack</h4>

<p>所有函数的呼叫都会进入调用堆栈。</p>

<p>书中对此没有详细解释，我的理解是，实际我们在写一个函数的时候，在其内部不出意料地会用到其他函数，有些很基础的函数可能都没意识到，比如 <code>+</code> <code>==</code> 或者如 <code>delete</code> <code>push</code> 等。至少在Ruby中，同一个名称的method在不同Class中可能有不同的处理方式，比如从一个string中delete一个字母和从array中delete一个element肯定是不同的。 所以这些基本的函数也可以算作stack中的一层。</p>

<hr />

<h4 id="recap">recap:</h4>

<ul>
  <li>Recursion is when a function calls itself</li>
  <li>Every recursive function has two cases: the base case and the recursive case</li>
  <li>A stack has two operations: push and pop (这个push不是array中的从尾部注入，而是在stack顶端叠加一层，pop则是拿掉最顶上的那层)</li>
  <li>All function calls go onto the call stack 所有函数的调用都会进入调用堆栈</li>
  <li>The call stack can get very large, which takes up a lot of memory</li>
</ul>

<hr />

<p>Exercise 3.1</p>

<p>Suppose I show you a call stack like this.</p>

<p>What information can you give me, just based on this call stack?</p>

<p>Now let’s see the call stack in action with a recursive function.</p>

<p><img src="https://s3-ap-southeast-1.amazonaws.com/image-for-articles/image-bucket-1/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7+2018-04-17+%E4%B8%8B%E5%8D%8811.35.57.png" alt="" /></p>

<p>greet function 先被叫到，带着变数name； 接着greet2也带着变数name被叫到；在当前时刻greet是挂起的未完成状态；当前位置是在 greet2 中；在greet2执行完后，greet 将会继续执行</p>

<p>3.2</p>

<p>Suppose you accidentally write a recursive function that runs forever. As you saw, your computer allocates memory on the stack for each function call. What happens to the stack when your recursive function runs forever?</p>

<p>stack会一直叠加。</p>

</div>

  </body>
</html>