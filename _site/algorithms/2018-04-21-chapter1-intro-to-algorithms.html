<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Algorithms 101 - 1 - intro to algorithms</title>
<!-- The styles.css referenced here is generated by Jekyll from the styles.scss -->
    <link rel="stylesheet" href="/assets/css/styles.css">
  </head>
  <body>
      <div class="post">

  <!-- <nav>
  
    <a href="/" >
      Home
    </a>
  
    <a href="/blog.html" >
      Blog
    </a>
  
    <a href="/photography.html" >
      Photography
    </a>
  
    <a href="/me.html" >
      Me
    </a>
  
</nav> -->


<!-- <div class="bar_nav">
  <p>Home</p>
  <p>Portfolio</p>
  <p>Blog</p>
  <p>Me</p>
</div> -->


<div class="bar_nav">
  
    
    <p ><a href="/">Home</a></p>
  
    
    <p  class="current" ><a href="/blog.html">Blog</a></p>
  
    
    <p ><a href="/photography.html">Photography</a></p>
  
    
    <p ><a href="/me.html">Me</a></p>
  
</div>

  <h1>Algorithms 101 - 1 - intro to algorithms</h1>
  <p>21 Apr 2018</p>


  <p><em>算法入门笔记，基于《Grokking Algorithms: An illustrated guide for programmers and other curious people》这本书的内容</em></p>

<h3 id="主要内容">主要内容：</h3>

<ul>
  <li>Binary search is a lot faster than simple search.    <br />
二分法搜索比普通搜索快很多（只对于有序列表来说）</li>
  <li>O(log n) is faster than O(n), but it gets a lot faster once the list of items you’re searching through grows.    <br />
O(log n) 比 O(n) 快很多，在搜索对象变多时，这种优势更明显</li>
  <li>Algorithm speed isn’t measured in seconds.    <br />
算法的速度并不是以秒为单位衡量</li>
  <li>Algorithm times are measured in terms of growth of an algorithm.     <br />
算法复杂度的衡量基于计算量如何增加</li>
  <li>Algorithm times are written in Big O notation.    <br />
算法复杂度用 Big O notation 表示</li>
</ul>

<hr />

<p>每一个代码片段都可以被称作一个 algorithm；很多常用的重要算法很可能在你所喜欢的语言中找到对应的实践；算法的选择是取舍的过程；有些问题到目前都还没有很有效的算法，只能拿到近似结果。</p>

<hr />

<h4 id="1-binary-search-is-a-lot-faster-than-simple-search">1 Binary search is a lot faster than simple search.</h4>

<p>工作前提（重要！）： binary search 是针对 <strong>ordered list 有序列表</strong> 的搜索算法，这是谈论前提。</p>

<p>假设要找到 <strong>ordered_list</strong> 中有没有 x 这个值</p>

<h5 id="11-如何工作">1.1 如何工作:</h5>

<ul>
  <li>前提：list 已经做过排序</li>
  <li>用index作为位置标记</li>
  <li>ordered list最左边的位置是0(as l_index)，最右边的是 list.length - 1 (as h_index)</li>
  <li>第一步猜ordered_list中间位置那个值
    <ul>
      <li>方法是 mid_index = (l_index + h_index) / 2，奇数相除会抹掉小数部分保留整数</li>
      <li>用 ordered_list[mid_index] 与 x 进行比较</li>
    </ul>
  </li>
  <li>基于上面的比较结果可以分成三种可能情况
    <ul>
      <li>1 刚好相等，那么找到了，搜索完成</li>
      <li>2 猜测值比 x 大
        <ul>
          <li>将 l_index 移到 (mid_index + 1) 位置， h_index 不动，再按之前取中间值的方法猜</li>
        </ul>
      </li>
      <li>3 猜测值比 x 小
        <ul>
          <li>将 l_index 移到 (mid_index - 1) 位置， h_index 不动，再按之前取中间值的方法猜</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>重复上面的步骤直至找到x，或者没有找到结果，完成搜索。</li>
</ul>

<h5 id="12-python代码示例">1.2 python代码示例:</h5>

<div class="language-python highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"> <a href="#n1" name="n1">1</a></span><span style="color:#080;font-weight:bold">def</span> <span style="color:#06B;font-weight:bold">binary_search</span>(ordered_list, item):
<span class="line-numbers"> <a href="#n2" name="n2">2</a></span>  low = <span style="color:#00D">0</span>
<span class="line-numbers"> <a href="#n3" name="n3">3</a></span>  high = <span style="color:#369;font-weight:bold">len</span>(ordered_list) - <span style="color:#00D">1</span>
<span class="line-numbers"> <a href="#n4" name="n4">4</a></span>
<span class="line-numbers"> <strong><a href="#n5" name="n5">5</a></strong></span>  <span style="color:#080;font-weight:bold">while</span> low &lt;= high:
<span class="line-numbers"> <a href="#n6" name="n6">6</a></span>    mid = (low + high)/<span style="color:#00D">2</span>
<span class="line-numbers"> <a href="#n7" name="n7">7</a></span>    guess = ordered_list[mid]
<span class="line-numbers"> <a href="#n8" name="n8">8</a></span>    <span style="color:#080;font-weight:bold">if</span> guess == item:
<span class="line-numbers"> <a href="#n9" name="n9">9</a></span>        <span style="color:#080;font-weight:bold">return</span> mid
<span class="line-numbers"><strong><a href="#n10" name="n10">10</a></strong></span>    <span style="color:#080;font-weight:bold">if</span> guess &gt; item:
<span class="line-numbers"><a href="#n11" name="n11">11</a></span>        high = mid - <span style="color:#00D">1</span>
<span class="line-numbers"><a href="#n12" name="n12">12</a></span>    <span style="color:#080;font-weight:bold">else</span>:
<span class="line-numbers"><a href="#n13" name="n13">13</a></span>        low = mid + <span style="color:#00D">1</span>
<span class="line-numbers"><a href="#n14" name="n14">14</a></span>  <span style="color:#080;font-weight:bold">return</span> <span style="color:#069">None</span>
<span class="line-numbers"><strong><a href="#n15" name="n15">15</a></strong></span>
<span class="line-numbers"><a href="#n16" name="n16">16</a></span>my_list = [<span style="color:#00D">1</span>,<span style="color:#00D">3</span>,<span style="color:#00D">5</span>,<span style="color:#00D">7</span>,<span style="color:#00D">9</span>]
<span class="line-numbers"><a href="#n17" name="n17">17</a></span>
<span class="line-numbers"><a href="#n18" name="n18">18</a></span><span style="color:#080;font-weight:bold">print</span> binary_search(my_list, <span style="color:#00D">3</span>) <span style="color:#777">#=&gt; 4</span>
<span class="line-numbers"><a href="#n19" name="n19">19</a></span><span style="color:#080;font-weight:bold">print</span> binary_search(my_list, -<span style="color:#00D">1</span>) <span style="color:#777">#=&gt; None</span>
</pre></div>
</div>
</div>

<p>用ruby写</p>

<div class="language-ruby highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"> <a href="#n1" name="n1">1</a></span><span style="color:#080;font-weight:bold">def</span> <span style="color:#06B;font-weight:bold">binary_search</span>(ordered_list, item)
<span class="line-numbers"> <a href="#n2" name="n2">2</a></span>  l_index = <span style="color:#00D">0</span>
<span class="line-numbers"> <a href="#n3" name="n3">3</a></span>  h_index = ordered_list.length - <span style="color:#00D">1</span>
<span class="line-numbers"> <a href="#n4" name="n4">4</a></span>
<span class="line-numbers"> <strong><a href="#n5" name="n5">5</a></strong></span>  <span style="color:#080;font-weight:bold">while</span> l_index &lt;=  h_index
<span class="line-numbers"> <a href="#n6" name="n6">6</a></span>    mid_index = (l_index + h_index)/<span style="color:#00D">2</span>
<span class="line-numbers"> <a href="#n7" name="n7">7</a></span>    guess = ordered_list[mid_index]
<span class="line-numbers"> <a href="#n8" name="n8">8</a></span>    <span style="color:#080;font-weight:bold">if</span> guess == item
<span class="line-numbers"> <a href="#n9" name="n9">9</a></span>      <span style="color:#080;font-weight:bold">return</span> <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">found item at index: </span><span style="background-color:hsla(0,0%,0%,0.07);color:black"><span style="font-weight:bold;color:#666">#{</span>mid_index<span style="font-weight:bold;color:#666">}</span></span><span style="color:#710">&quot;</span></span>
<span class="line-numbers"><strong><a href="#n10" name="n10">10</a></strong></span>    <span style="color:#080;font-weight:bold">elsif</span> guess &lt; item
<span class="line-numbers"><a href="#n11" name="n11">11</a></span>      l_index = mid_index + <span style="color:#00D">1</span>
<span class="line-numbers"><a href="#n12" name="n12">12</a></span>    <span style="color:#080;font-weight:bold">else</span>
<span class="line-numbers"><a href="#n13" name="n13">13</a></span>      h_index = mid_index - <span style="color:#00D">1</span>
<span class="line-numbers"><a href="#n14" name="n14">14</a></span>    <span style="color:#080;font-weight:bold">end</span>
<span class="line-numbers"><strong><a href="#n15" name="n15">15</a></strong></span>  <span style="color:#080;font-weight:bold">end</span>
<span class="line-numbers"><a href="#n16" name="n16">16</a></span>
<span class="line-numbers"><a href="#n17" name="n17">17</a></span>  <span style="color:#080;font-weight:bold">return</span> <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">Not found</span><span style="color:#710">&quot;</span></span>
<span class="line-numbers"><a href="#n18" name="n18">18</a></span><span style="color:#080;font-weight:bold">end</span>
</pre></div>
</div>
</div>

<p><strong>代码自释疑：</strong></p>

<ul>
  <li>注意这里的 low, hight, mid 都指的是 index，而不是具体值</li>
  <li>只有当1 找到目标值；2 low &gt; high (index)时，才会停止搜索</li>
  <li>这也是为什么下面的每次一index移动都会+1或-1
    <ul>
      <li>如果不这么做，给出一个list以外的值或端点值时，搜索将在每次范围收缩到最后两个值时陷入无限循环</li>
      <li>如果给出9
        <ul>
          <li>step1: i = (0+4)/2 = 2, list[2] = 5, too low, low = 2</li>
          <li>step2: i = (2+4)/2 = 3, list[3] = 7, too low, low = 3</li>
          <li>step3: i = (3+4)/2 = 3, list[3] = 7, too low, low = 3</li>
          <li>step … 从上一步开始 index 就卡在3一直循环</li>
        </ul>
      </li>
      <li>如果给出 -1
        <ul>
          <li>step1: i = (0+4)/2 = 2, list[2] = 5, too high, high = 2</li>
          <li>step2: i = (0+2)/2 = 1, list[1] = 3, too high, high = 1</li>
          <li>step3: i = (0 + 1)/2 = 0, list[0] = 1, too high, high= 0</li>
          <li>step4: i = (0 + 0)/2 = 0, list[0] = 1, too high, high= 0</li>
          <li>step … 从上一步开始 index 就卡在0一直循环</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>为什么每次 index 的 +1 和 -1 不会导致错过某个值？
    <ul>
      <li>首先，每次对比取的那个中点index对应的值(已经用于与目标值比较所以)已经被排除，所以</li>
      <li>too low 时，最低index可以不落在之前的中点index上，可以向右收缩一位</li>
      <li>too high 时，最高index可以不落在之前的中点index上，可以向左收缩一位</li>
      <li>其次，左右端点index所在的项最终都会拿出来作比较
        <ul>
          <li>不管搜索多少次，最后会收缩到端点index是相邻数字，比如 2和3</li>
          <li>因为二者相加再相除会刨去小数，拿到的会是较小的那个端点
            <ul>
              <li>如目标index是2，那么 (2+3)/2 = 2 搜索成功</li>
            </ul>
          </li>
          <li>如果不是，那么下一步就会变成端点index都落在右边较大那个index
            <ul>
              <li>如目标index是3，那么 (2+3)/2 = 2 会too low，左边的index会+1，然后得到两个端点index都是3</li>
              <li>(3+3)/2 = 3 搜索完成</li>
            </ul>
          </li>
          <li>至此最后剩余的两个端点index所在的值都拿来比较过了</li>
          <li>再下一步不管目标值是落在集合左边还是右边，左右端点index会交错，导致while loop遇到false中断</li>
        </ul>
      </li>
      <li>因此端点值无论怎么搜索是被包含在搜索项中的，从上一次的中点index收缩一步，并不会错过任何项</li>
    </ul>
  </li>
</ul>

<p>wikipedia 上 binary search 的示意图</p>

<p><img src="https://s3-ap-southeast-1.amazonaws.com/image-for-articles/image-bucket-1/470px-Binary_Search_Depiction.svg.png" alt="" /></p>

<h4 id="2-olog-n-is-faster-than-on-but-it-gets-a-lot-faster-once-the-list-of-items-youre-searching-through-grows">2 O(log n) is faster than O(n), but it gets a lot faster once the list of items you’re searching through grows.</h4>

<h5 id="21-big-o-notation">2.1 Big O notation</h5>

<p>Big O notation 是用来描述一个算法快慢（算法复杂度）的术语， O 指的是 operation，代表步骤或操作（不是以时间为单位）。</p>

<blockquote>
  <p>Big O notation lets you compare the number of operations. It tells you how fast the algorithm grows.</p>
</blockquote>

<p>O(n), O(logn) … 括号中的的值越大代表算法复杂度越高。</p>

<p>wikipedia 上关于不同 Big O notation 随着查找对象增加，算法复杂度的增加曲线</p>

<p><img src="https://s3-ap-southeast-1.amazonaws.com/image-for-articles/image-bucket-1/512px-Comparison_computational_complexity.svg.png" alt="" /></p>

<h5 id="22-olog-n-与-on">2.2 O(log n) 与 O(n)</h5>

<p>从 含有n个对象的 ordered_list 中搜索一个值 x 是否存在</p>
<ul>
  <li>从头开始一个一个找算法复杂度是 O(n)</li>
  <li>使用 binary search 搜索，算法复杂度是  O(log n)</li>
</ul>

<p>在ordered_list中对象数量较少时，算法复杂度相差不大，但随着列表中对象数量增加，binary search的优势会越来越明显。</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">list中的对象数量</th>
      <th style="text-align: center">O(n)需要的搜索次数</th>
      <th style="text-align: center">O(log n)需要的搜索次数</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">10</td>
      <td style="text-align: center">10</td>
      <td style="text-align: center">4</td>
    </tr>
    <tr>
      <td style="text-align: center">100</td>
      <td style="text-align: center">100</td>
      <td style="text-align: center">7</td>
    </tr>
    <tr>
      <td style="text-align: center">1 billion</td>
      <td style="text-align: center">1 billion</td>
      <td style="text-align: center">30</td>
    </tr>
  </tbody>
</table>

<h4 id="3-algorithm-speed-isnt-measured-in-seconds">3 Algorithm speed isn’t measured in seconds.</h4>

<p>每增加一次搜索，算法复杂度 +1，等于多需要一步，每一步需要的单位时间因条件而不同。Big O notation 不是以时间作为单位。</p>

<h4 id="4-traveling-salesperson-problem">4 Traveling salesperson problem</h4>

<p><img src="https://s3-ap-southeast-1.amazonaws.com/image-for-articles/image-bucket-1/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7+2018-04-16+%E4%B8%8B%E5%8D%884.54.55.png" alt="" /></p>

<blockquote>
  <p>This is one of the unsolved problems in computer science. There’s no fast known algorithm for it, and smart people think it’s impossible to have a smart algorithm for this problem. The best we can do is come up with an approximate solution.</p>
</blockquote>

<p>一个还没找到有效算法的问题。地图上给出若干个点，要如何用最短的路程走完所有的点。</p>
<ul>
  <li>如果给出4个点, 会有 4! = 24 种路线组合</li>
  <li>如果给出6个点，会有 6! = 720 种路线组合</li>
  <li>如果给出8个点，有 40320 种路线组合</li>
  <li>如果给出 100 个点 …</li>
</ul>

<p><img src="https://s3-ap-southeast-1.amazonaws.com/image-for-articles/image-bucket-1/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7+2018-04-16+%E4%B8%8B%E5%8D%884.55.30.png" alt="" /></p>

<h4 id="5-wikipedia-上的算法清单">5 wikipedia 上的算法清单</h4>

<p>https://en.wikipedia.org/wiki/List_of_algorithms</p>

<hr />

<p>Recap:</p>

<ul>
  <li>Binary search is a lot faster than simple search.</li>
  <li>O(log n) is faster than O(n), but it gets a lot faster once the list of items you’re searching through grows.</li>
  <li>Algorithm speed isn’t measured in seconds.</li>
  <li>Algorithm times are measured in terms of growth of an algorithm.</li>
  <li>Algorithm times are written in Big O notation.</li>
</ul>

</div>

  </body>
</html>