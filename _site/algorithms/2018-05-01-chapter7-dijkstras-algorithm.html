<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Algorithms 101 - 7 - dijkstra's algorithm</title>
<!-- The styles.css referenced here is generated by Jekyll from the styles.scss -->
    <link rel="stylesheet" href="/assets/css/styles.css">
  </head>
  <body>
      <div class="post">

  <!-- <nav>
  
    <a href="/" >
      Home
    </a>
  
    <a href="/blog.html" >
      Blog
    </a>
  
    <a href="/photography.html" >
      Photography
    </a>
  
    <a href="/me.html" >
      Me
    </a>
  
</nav> -->


<!-- <div class="bar_nav">
  <p>Home</p>
  <p>Portfolio</p>
  <p>Blog</p>
  <p>Me</p>
</div> -->


<div class="bar_nav">
  
    
    <p ><a href="/">Home</a></p>
  
    
    <p  class="current" ><a href="/blog.html">Blog</a></p>
  
    
    <p ><a href="/photography.html">Photography</a></p>
  
    
    <p ><a href="/me.html">Me</a></p>
  
</div>

  <h1>Algorithms 101 - 7 - dijkstra's algorithm</h1>
  <p>01 May 2018</p>


  <p><em>算法入门笔记，基于《Grokking Algorithms: An illustrated guide for programmers and other curious people》这本书的内容</em></p>

<h4 id="主要内容">主要内容</h4>

<ul>
  <li>We continue the discussion of graphs, and you learn about weighted graphs: a way to assign more or less weight to some edges. <br />
继续讨论 graphs 这种数据结构, 不过是带有weight权重的graphs: 这种graphs会给edges赋予不同的weight</li>
  <li>You learn Dijkstra’s algorithm, which lets you answer “What’s the shortest path to X?” for weighted graphs.   <br />
将会学习 Dijkstra 算法，用来计算两点之间最小weight的问题。</li>
</ul>

<hr />

<p>说明：此章内容理解比较依赖对graph整体图景的把握，作者为了表达上的具体生动，使用了很多具象的名称附加到graph上。个人认为反而增加的理解难度，尤其对非英语母语的人。因此代码示例会使用另外一个例子，这个例子取自 youtube 上的一个教学视频，讲解相对清楚。其他部分内容会综合书中讲解展开。</p>

<p>视频地址：  https://www.youtube.com/watch?v=5GT5hYzjNoo</p>

<hr />

<h4 id="1-导言">1 导言</h4>

<p>首先回顾前面breadth first search的内容。在breadth first search中，我们以源vertex作为起点，逐层扫描neighbor节点，直至找到目标对象或路径。在整个过程中每个edge被视作完全相等的。这是一种相对理想的状态，实际情况中，两两对象之间的距离，或抵达成本，或其他成本往往是不同的。</p>

<p>A到B以及A到C,同样都只经过1个edge</p>
<ul>
  <li>但A到B可能是100米</li>
  <li>B到C可能是50米</li>
</ul>

<p>那么就可以说这两个edge具有不同的weight。</p>

<p>对应到两点之间的乘车问题，空间最省的不一定是时间最省的。</p>
<ul>
  <li>A -&gt; C -&gt; D 总路程是 50km， 总耗时100分钟。(省道)</li>
  <li>A -&gt; B -&gt; D 总路程是 100km, 但总耗时也许只要50分钟。(高速)</li>
</ul>

<p>所以将什么属性作为edge的weight也是视具体要解决的问题，或优先要考虑的因素而定。可以把每段路程的耗时作为weight也可以把每段路程的长度作为weight。甚至可以把每段路程的舒适程度或风景好坏程度作为weight。</p>

<p>书中例子使用的是两点之间的耗时作为weight。</p>

<p><img src="https://s3-ap-southeast-1.amazonaws.com/image-for-articles/image-bucket-1/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7+2018-04-24+%E4%B8%8B%E5%8D%883.27.58.png" alt="" /></p>

<p>这种在graph上计算edge带weight的问题的算法之一就是， Dijkstra’s algorithm。</p>

<p>https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm</p>

<p><strong>weighted graph 和 unweighted graph</strong></p>

<p>根据名称，定义就很清楚了。</p>

<h4 id="2-working-with-dijkstras-algorithm">2 Working with Dijkstra’s algorithm</h4>

<h5 id="21-dijkstras-algorithms-basic-steps">2.1 Dijkstra’s algorithm’s basic steps</h5>

<p>基于找到两点间最省时的例子，Dijkstra 算法遵循的几个（循环）基本步骤是：</p>

<p>每个node的节点值指的是从起点node到达这个node所历经的所有edges的weight的总和，而起点node到达某node的路径可能有很多条，那么可能的weight就有很多个。</p>

<ol>
  <li>
    <p>找到最目前最省时的node,如果是刚开始时就是源节点，可以把此时的weight视作0</p>
  </li>
  <li>找到当前node的所有neighbors, 用当前最省时node的weight分别加上到达其各个neighbor的的weight值。然后比对更新
    <ul>
      <li>如果某个neighbor还没有weight值，那么就把算出来的值作为他的weight保留</li>
      <li>如果某个neighbor已经有了weight值
        <ul>
          <li>如果算出来新的weight比原有的小，就取代之</li>
          <li>否则仍然保留原来的weight</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p>排除刚刚作为源节点的node, 留下剩余节点，重复上面的过程，先找到weight最低的node，然后计算，更新，直至所有node都被作为当前最低weight的node处理过之后</p>
  </li>
  <li>计算最终结果</li>
</ol>

<h5 id="22-meeting-cycles-and-negative-weights">2.2 Meeting cycles and negative weights</h5>

<p><strong>关于cycle</strong></p>

<p>之前提到 Dijkstra’s algorithm 无法处理graph中存在cycle的情况。这是一个错误陈述。</p>

<p>https://stackoverflow.com/questions/43394847/dijkstras-algorithm-and-cycles</p>

<p>如果使用一个array来逐步记录已经作为中心节点处理过的 nodes, 那么不仅edge全是正数的cycle，连<strong>某些</strong>带负数的cycle也可以处理。</p>

<p><strong>关于negative weight</strong></p>

<p>而关于negative weight, 某些情况下下dijkstra’s algorithm可以处理，有些则不能。下面这些回答中包含两种情况，问题中包含的情况，negative weight 没有影响到最后结果的正确性，而回答中给出了一个会影响结果的例子。</p>

<p>Negative weights using Dijkstra’s Algorithm</p>

<p>https://stackoverflow.com/questions/6799172/negative-weights-using-dijkstras-algorithm?rq=1</p>

<p>https://stackoverflow.com/questions/13159337/why-doesnt-dijkstras-algorithm-work-for-negative-weight-edges</p>

<p>但cycle和negative weight的情况相对特殊，下面讨论都以排除这两种情况为前提。</p>

<h5 id="23-trading-for-a-piano">2.3 Trading for a piano</h5>

<p>书上给出的例子：</p>

<p>Rama is trying to trade a music book for a piano.</p>

<p>“I’ll give you this poster for your book,” says Alex. “It’s a poster of my favorite band, Destroyer. Or I’ll give you this rare LP of Rick Astley for your book and $5 more.” “Ooh, I’ve heard that LP has a really great song,” says Amy. “I’ll trade you my guitar or drum set for the poster or the LP.</p>

<p>“I’ve been meaning to get into guitar!” exclaims Beethoven. “Hey, I’ll trade you my piano for either of Amy’s things.”</p>

<p>Perfect! With a little bit of money, Rama can trade his way from a piano book to a real piano. Now he just needs to figure out how to spend the least amount of money to make those trades. Let’s graph out what he’s been offered.”</p>

<p>摘录来自: Aditya Y. Bhargava. “Grokking Algorithms: An illustrated guide for programmers and other curious people。” iBooks.</p>

<p>Rama 手里有1本book，他想用这本 book 去交换些什么东西（实际他也许并不知道他最后可能换到1台piano）接下来的剧情是：</p>
<ul>
  <li>Alex 愿意无条件用 poster 换 Rama的 book</li>
  <li>Alex 同时也愿意收取 Rama 5块钱把自己的 LP 换成 Rama 的 book</li>
  <li>Amy 愿意用自己的Guitar(收15块) 或 Drum(收35块) 换 Alex 的 LP</li>
  <li>Beethoven 愿意用自己的piano 换 Amy 的 Guitar(收20块) 或 Drum(收10块)</li>
</ul>

<p>这整个是一个交叉的网状结构，使用graph将其在图面上表达出来才能较好理解其中关系。</p>

<p><img src="https://s3-ap-southeast-1.amazonaws.com/image-for-articles/image-bucket-1/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7+2018-04-24+%E4%B8%8B%E5%8D%887.54.23.png" alt="" /></p>

<p>回顾一下 Dijkstra’s algorithm 的套路</p>

<ol>
  <li>
    <p>找到最目前weight最小的node,如果是刚开始时就是源节点，可以把此时的weight视作0</p>
  </li>
  <li>找到当前node的所有neighbors, 用当前最省时node的weight分别加上到达其各个neighbor的的weight值。然后比对更新
    <ul>
      <li>如果某个neighbor还没有weight值，那么就把算出来的值作为他的weight保留</li>
      <li>如果某个neighbor已经有了weight值
        <ul>
          <li>如果算出来新的weight比原有的小，就取代之</li>
          <li>否则仍然保留原来的weight</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p>排除刚刚作为源节点的node, 留下剩余节点，重复上面的过程，先找到weight最低的node，然后计算，更新，直至所有node都被作为当前最低weight的node处理过之后</p>
  </li>
  <li>计算最终结果</li>
</ol>

<p>表格化的计算过程：</p>

<p><img src="https://s3-ap-southeast-1.amazonaws.com/image-for-articles/image-bucket-1/piano.jpg" alt="" /></p>

<p>简单描述这个过程：</p>

<p>第一步：</p>
<ul>
  <li>将 book 作为中心节点， 并把他的 weight 设为0，记录下其parent node，还是 book, 也可以理解从 book 到 book 的weight 是 0。这一步相当于设置一个初始状态。</li>
  <li>然后计算从 book 节点到其所有neighbors的weight，将他们的parent都记为book。book不能直接到达的点设为 Infinity</li>
  <li>将 book 加入 processed nodes 数组，锁定book节点的weight值，不再更新。</li>
  <li>从此行剩余的节点中找出 weight 最低的那个– Poster， 将其作为下一次计算的中心节点</li>
</ul>

<p>第二步：</p>
<ul>
  <li>将 Poster 作为中心节点。</li>
  <li>然后计算从 Poster 节点到其所有neighbors的weight
    <ul>
      <li>如果算出来的值小于之前这个neighbor节点的记录值，那么更新其weight以及parent(设为poster, 因为你经过poster找到到达这个neighbor更短的线路)</li>
      <li>如果算出来的值大于等于其neighbor之前的weight值，那么保持不变</li>
      <li>不能抵达的仍然保持 Infinity</li>
    </ul>
  </li>
  <li>将 poster 加入 processed nodes 数组，锁定poster节点的weight值，不再更新。</li>
  <li>从此行剩余的节点中找出 weight 最低的那个– LP ， 将其作为下一次计算的中心节点</li>
</ul>

<p>如此循环，直至中心计算节点到达目标 piano。</p>

<h5 id="24-代码实现思路">2.4 代码实现思路</h5>

<p>这类带有指向的结构作者同样使用了 hash table 的方式。</p>

<p>1 首先使用一个 costs hash 来追踪每个node当前的weight值</p>
<ul>
  <li>比如对应到上面book-piano的第一步就记录为
  <code>costs = { "book" =&gt; 0, "poster" =&gt; 0, "LP" =&gt; 5, "Guitar" =&gt; Infinity, "Drum" =&gt; Infinity, "Piano" =&gt; Infinity }</code></li>
</ul>

<p>2 同样使用一个 parents hash 来追踪每一个node的 parent 变化
<code>parents = { "book" =&gt; nil, "poster" =&gt; "book", "LP" =&gt; "book", "Guitar" =&gt; nil, "Drum" =&gt; nil, "Piano" =&gt; nil}</code></p>

<p>3 还需要一个 hash 来记录每个 edge 的weight值，但edge没有名称，所以加上一层嵌套用 <code>{中心节点 =&gt; { neighbor1 =&gt; D1, neighbor2 =&gt; D2 }}</code> 这样的结构模拟
比如 <code>graph = { "book" =&gt; { "Lp" =&gt; 5, "Poster" =&gt;0 }, "Poster" =&gt; { "Guitar" =&gt; 30, "Drums" =&gt; 35 } ...... }</code> 这样一直记完所有节点</p>

<p>4 用一个 Array 来记录已经当做中心节点处理过的 nodes <code>proccessed_nodes = []</code></p>

<p><strong>hash tables的使用方法</strong></p>

<ul>
  <li>costs hash 是一个会不断更新的 hash, 随着不断找到新的 weight 更低的路径，取得某个node当前的weight值只用 <code>costs[node]</code></li>
  <li>parents hash 的更新跟 costs 同步，因为新的路径表明着更换了新的parent node</li>
  <li>如果要取得某一段edge的weight, 使用 graph hash 比如 <code>graph['post']['Guitar']</code> 可以拿到从 poster 到 Guitar 这段edge的weight</li>
  <li>使用 array 记录已经当做中心节点处理过的 node 的原因是
    <ul>
      <li>每一次当做中心节点的node,都是从前一步中选出的最低weight所在的node，这个node将被视作到它的最小weight，以后不再更新</li>
      <li>记录下这部分node，可以避免遇到cycle陷入循环或重复处理某些nodes。</li>
    </ul>
  </li>
</ul>

<p>利用上面的 hash 和 array 我们就将整个 graph 结构抽象了出来，下一步就只需要用代码模拟 Dijkstra’s algorithm 的循环步骤</p>

<h5 id="25-简化版案例的-python-伪代码">2.5 简化版案例的 python 伪代码</h5>

<p>书中给出了一个更简化的例子</p>

<p><img src="https://s3-ap-southeast-1.amazonaws.com/image-for-articles/image-bucket-1/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7+2018-04-24+%E4%B8%8B%E5%8D%889.03.05.png" alt="" /></p>

<p>同样需要先把节点以及节点之间的edge抽象为 hash table, 步骤省略。看伪代码</p>

<p>python:</p>

<div class="language-python highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"> <a href="#n1" name="n1">1</a></span><span style="color:#080;font-weight:bold">def</span> <span style="color:#06B;font-weight:bold">find_lowest_cost_node</span>(costs):
<span class="line-numbers"> <a href="#n2" name="n2">2</a></span>  lowest_cost = <span style="color:#369;font-weight:bold">float</span>(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">inf</span><span style="color:#710">&quot;</span></span>)
<span class="line-numbers"> <a href="#n3" name="n3">3</a></span>  lowest_cost_node = <span style="color:#069">None</span>
<span class="line-numbers"> <a href="#n4" name="n4">4</a></span>  <span style="color:#080;font-weight:bold">for</span> node <span style="color:#080;font-weight:bold">in</span> costs:
<span class="line-numbers"> <strong><a href="#n5" name="n5">5</a></strong></span>    cost = costs[node]
<span class="line-numbers"> <a href="#n6" name="n6">6</a></span>    <span style="color:#080;font-weight:bold">if</span> cost &lt; lowest_cost <span style="color:#080;font-weight:bold">and</span> node <span style="color:#080;font-weight:bold">not</span> <span style="color:#080;font-weight:bold">in</span> processed:
<span class="line-numbers"> <a href="#n7" name="n7">7</a></span>      lowest_cost = cost
<span class="line-numbers"> <a href="#n8" name="n8">8</a></span>      lowest_cost_node = node
<span class="line-numbers"> <a href="#n9" name="n9">9</a></span>  <span style="color:#080;font-weight:bold">return</span> lowest_cost_node
<span class="line-numbers"><strong><a href="#n10" name="n10">10</a></strong></span>
<span class="line-numbers"><a href="#n11" name="n11">11</a></span>
<span class="line-numbers"><a href="#n12" name="n12">12</a></span>node = find_lowest_cost_node(costs) <span style="color:#777"># 初始化 costs</span>
<span class="line-numbers"><a href="#n13" name="n13">13</a></span><span style="color:#080;font-weight:bold">while</span> node <span style="color:#080;font-weight:bold">is</span> <span style="color:#080;font-weight:bold">not</span> <span style="color:#069">None</span>:
<span class="line-numbers"><a href="#n14" name="n14">14</a></span>  cost = costs[node]
<span class="line-numbers"><strong><a href="#n15" name="n15">15</a></strong></span>  neighbors = graph[node]
<span class="line-numbers"><a href="#n16" name="n16">16</a></span>  <span style="color:#080;font-weight:bold">for</span> n <span style="color:#080;font-weight:bold">in</span> neighbors.keys():
<span class="line-numbers"><a href="#n17" name="n17">17</a></span>    new_cost = cost + neighbors[n]
<span class="line-numbers"><a href="#n18" name="n18">18</a></span>    <span style="color:#080;font-weight:bold">if</span> costs[n] &gt; new_cost:
<span class="line-numbers"><a href="#n19" name="n19">19</a></span>      costs[n] = new_cost
<span class="line-numbers"><strong><a href="#n20" name="n20">20</a></strong></span>      parents[n] = node
<span class="line-numbers"><a href="#n21" name="n21">21</a></span>  processed.append(node)
<span class="line-numbers"><a href="#n22" name="n22">22</a></span>  node = find_lowest_cost_node(costs) <span style="color:#777"># 找到下一个中心节点</span>
</pre></div>
</div>
</div>

<h4 id="3-ruby-代码实现">3 Ruby 代码实现</h4>

<p>Ruby 代码graph基于前面提到的视频，其graph是这样的</p>

<p><img src="https://s3-ap-southeast-1.amazonaws.com/image-for-articles/image-bucket-1/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7+2018-04-21+%E4%B8%8B%E5%8D%8811.02.40.png" alt="" /></p>

<p>当然这里已经给出结果，具体过程可以看原视频。</p>

<p><strong>注：代码中对象的命名尽量使用表意的名称，所以会比较长，但看起来会比较好理解</strong></p>

<h5 id="31-无-class-封装版本">3.1 无 class 封装版本</h5>

<p>注意这里准备各种hash的过程有些是在不同 methods 中利用 graph_segments hash 生成，这样灵活度会高些</p>

<p>不然每次要改3个hash</p>

<div class="language-ruby highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"> <a href="#n1" name="n1">1</a></span>from_a = { <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">a</span><span style="color:#710">&quot;</span></span> =&gt; { <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">b</span><span style="color:#710">&quot;</span></span>=&gt;<span style="color:#00D">8</span>, <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">d</span><span style="color:#710">&quot;</span></span>=&gt;<span style="color:#00D">5</span>, <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">c</span><span style="color:#710">&quot;</span></span>=&gt;<span style="color:#00D">2</span> } }
<span class="line-numbers"> <a href="#n2" name="n2">2</a></span>from_b = { <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">b</span><span style="color:#710">&quot;</span></span> =&gt; { <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">d</span><span style="color:#710">&quot;</span></span>=&gt;<span style="color:#00D">2</span>, <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">f</span><span style="color:#710">&quot;</span></span>=&gt;<span style="color:#00D">13</span> } }
<span class="line-numbers"> <a href="#n3" name="n3">3</a></span>from_c = { <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">c</span><span style="color:#710">&quot;</span></span> =&gt; { <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">d</span><span style="color:#710">&quot;</span></span>=&gt;<span style="color:#00D">2</span>, <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">e</span><span style="color:#710">&quot;</span></span>=&gt;<span style="color:#00D">5</span> } }
<span class="line-numbers"> <a href="#n4" name="n4">4</a></span>from_d = { <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">d</span><span style="color:#710">&quot;</span></span> =&gt; { <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">b</span><span style="color:#710">&quot;</span></span>=&gt;<span style="color:#00D">2</span>, <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">e</span><span style="color:#710">&quot;</span></span>=&gt;<span style="color:#00D">1</span>, <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">f</span><span style="color:#710">&quot;</span></span>=&gt;<span style="color:#00D">6</span>, <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">g</span><span style="color:#710">&quot;</span></span>=&gt;<span style="color:#00D">3</span> } }
<span class="line-numbers"> <strong><a href="#n5" name="n5">5</a></strong></span>from_e = { <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">e</span><span style="color:#710">&quot;</span></span> =&gt; { <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">g</span><span style="color:#710">&quot;</span></span>=&gt;<span style="color:#00D">1</span> } }
<span class="line-numbers"> <a href="#n6" name="n6">6</a></span>from_f = { <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">f</span><span style="color:#710">&quot;</span></span> =&gt; { <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">g</span><span style="color:#710">&quot;</span></span>=&gt;<span style="color:#00D">2</span>, <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">h</span><span style="color:#710">&quot;</span></span>=&gt;<span style="color:#00D">3</span> } }
<span class="line-numbers"> <a href="#n7" name="n7">7</a></span>from_g = { <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">g</span><span style="color:#710">&quot;</span></span> =&gt; { <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">f</span><span style="color:#710">&quot;</span></span>=&gt;<span style="color:#00D">2</span>, <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">h</span><span style="color:#710">&quot;</span></span>=&gt;<span style="color:#00D">6</span> } }
<span class="line-numbers"> <a href="#n8" name="n8">8</a></span>from_h = { <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">h</span><span style="color:#710">&quot;</span></span> =&gt; { <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">h</span><span style="color:#710">&quot;</span></span>=&gt;<span style="color:#00D">0</span> }}
<span class="line-numbers"> <a href="#n9" name="n9">9</a></span>
<span class="line-numbers"><strong><a href="#n10" name="n10">10</a></strong></span>graph_segments = [from_a, from_b, from_c, from_d, from_e, from_f, from_g, from_h].reduce { |graph, hash|  graph.merge! hash }
<span class="line-numbers"><a href="#n11" name="n11">11</a></span>
<span class="line-numbers"><a href="#n12" name="n12">12</a></span><span style="color:#777"># ---------------------------------------------------------</span>
<span class="line-numbers"><a href="#n13" name="n13">13</a></span>
<span class="line-numbers"><a href="#n14" name="n14">14</a></span><span style="color:#080;font-weight:bold">def</span> <span style="color:#06B;font-weight:bold">all_nodes</span>(graph_segments)
<span class="line-numbers"><strong><a href="#n15" name="n15">15</a></strong></span>  graph_segments.keys
<span class="line-numbers"><a href="#n16" name="n16">16</a></span><span style="color:#080;font-weight:bold">end</span>
<span class="line-numbers"><a href="#n17" name="n17">17</a></span>
<span class="line-numbers"><a href="#n18" name="n18">18</a></span><span style="color:#080;font-weight:bold">def</span> <span style="color:#06B;font-weight:bold">initialize_costs</span>(all_nodes, source_vertex)
<span class="line-numbers"><a href="#n19" name="n19">19</a></span>  costs = { source_vertex =&gt; <span style="color:#00D">0</span> }
<span class="line-numbers"><strong><a href="#n20" name="n20">20</a></strong></span>  (all_nodes - [source_vertex]).each { |node| costs[node] = <span style="color:#036;font-weight:bold">Float</span>::<span style="color:#036;font-weight:bold">INFINITY</span> }
<span class="line-numbers"><a href="#n21" name="n21">21</a></span>  costs
<span class="line-numbers"><a href="#n22" name="n22">22</a></span><span style="color:#080;font-weight:bold">end</span>
<span class="line-numbers"><a href="#n23" name="n23">23</a></span>
<span class="line-numbers"><a href="#n24" name="n24">24</a></span><span style="color:#080;font-weight:bold">def</span> <span style="color:#06B;font-weight:bold">initialize_parents</span>(nodes)
<span class="line-numbers"><strong><a href="#n25" name="n25">25</a></strong></span>  parents = {}
<span class="line-numbers"><a href="#n26" name="n26">26</a></span>  nodes.each { |node| parents[node] = <span style="color:#069">nil</span> }
<span class="line-numbers"><a href="#n27" name="n27">27</a></span>  parents
<span class="line-numbers"><a href="#n28" name="n28">28</a></span><span style="color:#080;font-weight:bold">end</span>
<span class="line-numbers"><a href="#n29" name="n29">29</a></span>
<span class="line-numbers"><strong><a href="#n30" name="n30">30</a></strong></span><span style="color:#080;font-weight:bold">def</span> <span style="color:#06B;font-weight:bold">calculate_costs</span>(graph_segments, source_vertex)
<span class="line-numbers"><a href="#n31" name="n31">31</a></span>    nodes = all_nodes(graph_segments)
<span class="line-numbers"><a href="#n32" name="n32">32</a></span>    current_proccessing_node = source_vertex
<span class="line-numbers"><a href="#n33" name="n33">33</a></span>    unproccessed_nodes = nodes
<span class="line-numbers"><a href="#n34" name="n34">34</a></span>    costs = initialize_costs(nodes, source_vertex)
<span class="line-numbers"><strong><a href="#n35" name="n35">35</a></strong></span>    parents = initialize_parents(nodes)
<span class="line-numbers"><a href="#n36" name="n36">36</a></span>
<span class="line-numbers"><a href="#n37" name="n37">37</a></span>    <span style="color:#080;font-weight:bold">while</span> unproccessed_nodes.include?(current_proccessing_node)
<span class="line-numbers"><a href="#n38" name="n38">38</a></span>      lowest_cost = costs[current_proccessing_node]
<span class="line-numbers"><a href="#n39" name="n39">39</a></span>      neighbors = graph_segments[current_proccessing_node].keys
<span class="line-numbers"><strong><a href="#n40" name="n40">40</a></strong></span>
<span class="line-numbers"><a href="#n41" name="n41">41</a></span>        neighbors.each <span style="color:#080;font-weight:bold">do</span> |neighbor|
<span class="line-numbers"><a href="#n42" name="n42">42</a></span>          new_cost = lowest_cost + graph_segments[current_proccessing_node][neighbor]
<span class="line-numbers"><a href="#n43" name="n43">43</a></span>          <span style="color:#080;font-weight:bold">if</span> new_cost &lt; costs[neighbor]
<span class="line-numbers"><a href="#n44" name="n44">44</a></span>            costs[neighbor] = new_cost
<span class="line-numbers"><strong><a href="#n45" name="n45">45</a></strong></span>            parents[neighbor] = current_proccessing_node
<span class="line-numbers"><a href="#n46" name="n46">46</a></span>          <span style="color:#080;font-weight:bold">end</span>
<span class="line-numbers"><a href="#n47" name="n47">47</a></span>        <span style="color:#080;font-weight:bold">end</span>
<span class="line-numbers"><a href="#n48" name="n48">48</a></span>
<span class="line-numbers"><a href="#n49" name="n49">49</a></span>      unproccessed_nodes -= [current_proccessing_node]
<span class="line-numbers"><strong><a href="#n50" name="n50">50</a></strong></span>      proccessed_nodes = nodes - unproccessed_nodes
<span class="line-numbers"><a href="#n51" name="n51">51</a></span>      lowest_cost = costs.values_at(*(unproccessed_nodes)).min
<span class="line-numbers"><a href="#n52" name="n52">52</a></span>      possible_lowest_cost_nodes = costs.select { |k, v| v == lowest_cost }
<span class="line-numbers"><a href="#n53" name="n53">53</a></span>        proccessed_nodes.each <span style="color:#080;font-weight:bold">do</span> |proccessed_node|
<span class="line-numbers"><a href="#n54" name="n54">54</a></span>          possible_lowest_cost_nodes.delete(proccessed_node)
<span class="line-numbers"><strong><a href="#n55" name="n55">55</a></strong></span>        <span style="color:#080;font-weight:bold">end</span>
<span class="line-numbers"><a href="#n56" name="n56">56</a></span>      current_proccessing_node = possible_lowest_cost_nodes.key(lowest_cost)
<span class="line-numbers"><a href="#n57" name="n57">57</a></span>    <span style="color:#080;font-weight:bold">end</span>
<span class="line-numbers"><a href="#n58" name="n58">58</a></span>
<span class="line-numbers"><a href="#n59" name="n59">59</a></span>    puts <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#b0b">\n</span><span style="color:#D20">Final updated costs from source_vertex is: </span><span style="color:#b0b">\n</span><span style="color:#D20"> </span><span style="background-color:hsla(0,0%,0%,0.07);color:black"><span style="font-weight:bold;color:#666">#{</span>costs<span style="font-weight:bold;color:#666">}</span></span><span style="color:#710">&quot;</span></span>
<span class="line-numbers"><strong><a href="#n60" name="n60">60</a></strong></span>    puts <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#b0b">\n</span><span style="color:#D20">Following the lowest cost path, every node's parent is: </span><span style="color:#b0b">\n</span><span style="color:#D20"> </span><span style="background-color:hsla(0,0%,0%,0.07);color:black"><span style="font-weight:bold;color:#666">#{</span>parents<span style="font-weight:bold;color:#666">}</span></span><span style="color:#D20"> </span><span style="color:#b0b">\n</span><span style="color:#710">&quot;</span></span>
<span class="line-numbers"><a href="#n61" name="n61">61</a></span><span style="color:#080;font-weight:bold">end</span>
<span class="line-numbers"><a href="#n62" name="n62">62</a></span>
<span class="line-numbers"><a href="#n63" name="n63">63</a></span>calculate_costs(graph_segments, <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">a</span><span style="color:#710">&quot;</span></span>)
<span class="line-numbers"><a href="#n64" name="n64">64</a></span>
<span class="line-numbers"><strong><a href="#n65" name="n65">65</a></strong></span>
<span class="line-numbers"><a href="#n66" name="n66">66</a></span><span style="color:#777"># Notice towarding the end of calculate_costs method, there is a possible_lowest_cost_nodes</span>
<span class="line-numbers"><a href="#n67" name="n67">67</a></span><span style="color:#777"># The operations below aim to avoid situation like this:</span>
<span class="line-numbers"><a href="#n68" name="n68">68</a></span><span style="color:#777"># At some point in costs, there might have multi nodes point to a same value</span>
<span class="line-numbers"><a href="#n69" name="n69">69</a></span><span style="color:#777"># If these nodes include a proccessed one, it should have cleared out from</span>
<span class="line-numbers"><strong><a href="#n70" name="n70">70</a></strong></span><span style="color:#777"># the unproccessed_nodes array</span>
<span class="line-numbers"><a href="#n71" name="n71">71</a></span><span style="color:#777"># But if we use current_proccessing_node = costs.key(lowest_cost)</span>
<span class="line-numbers"><a href="#n72" name="n72">72</a></span><span style="color:#777"># to update the node that will be handled in next loop, it may choose</span>
<span class="line-numbers"><a href="#n73" name="n73">73</a></span><span style="color:#777"># the proccessed one.</span>
<span class="line-numbers"><a href="#n74" name="n74">74</a></span><span style="color:#777"># Thus will lead while condition fail, then the whole procedure is broken</span>
<span class="line-numbers"><strong><a href="#n75" name="n75">75</a></strong></span>
<span class="line-numbers"><a href="#n76" name="n76">76</a></span><span style="color:#777"># The solution is choosing next current_proccessing_node only from unproccessed_nodes</span>
</pre></div>
</div>
</div>

<p>结果</p>

<div class="language-ruby highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"><a href="#n1" name="n1">1</a></span><span style="color:#036;font-weight:bold">Final</span> updated costs from source_vertex <span style="color:#606">is</span>:
<span class="line-numbers"><a href="#n2" name="n2">2</a></span> {<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">a</span><span style="color:#710">&quot;</span></span>=&gt;<span style="color:#00D">0</span>, <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">b</span><span style="color:#710">&quot;</span></span>=&gt;<span style="color:#00D">6</span>, <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">c</span><span style="color:#710">&quot;</span></span>=&gt;<span style="color:#00D">2</span>, <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">d</span><span style="color:#710">&quot;</span></span>=&gt;<span style="color:#00D">4</span>, <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">e</span><span style="color:#710">&quot;</span></span>=&gt;<span style="color:#00D">5</span>, <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">f</span><span style="color:#710">&quot;</span></span>=&gt;<span style="color:#00D">8</span>, <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">g</span><span style="color:#710">&quot;</span></span>=&gt;<span style="color:#00D">6</span>, <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">h</span><span style="color:#710">&quot;</span></span>=&gt;<span style="color:#00D">11</span>}
<span class="line-numbers"><a href="#n3" name="n3">3</a></span>
<span class="line-numbers"><a href="#n4" name="n4">4</a></span><span style="color:#036;font-weight:bold">Following</span> the lowest cost path, every node<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">s parent is:</span></span>
<span class="line-numbers"><strong><a href="#n5" name="n5">5</a></strong></span><span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#D20"> {&quot;a&quot;=&gt;nil, &quot;b&quot;=&gt;&quot;d&quot;, &quot;c&quot;=&gt;&quot;a&quot;, &quot;d&quot;=&gt;&quot;c&quot;, &quot;e&quot;=&gt;&quot;d&quot;, &quot;f&quot;=&gt;&quot;g&quot;, &quot;g&quot;=&gt;&quot;e&quot;, &quot;h&quot;=&gt;&quot;f&quot;}</span></span>
<span class="line-numbers"><a href="#n6" name="n6">6</a></span><span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#D20"></span></span></pre></div>
</div>
</div>

<h5 id="32-使用-class-封装">3.2 使用 class 封装</h5>

<p>这里将 Graph 抽成一个 class, 这样每一个新的 graph 都可以用一个 Graph 的 instance 代表</p>

<p>将 dijkstra’s algorithm 写成一个 instance method 这样可以对不同的 graph 都进行计算，适用度更广。</p>

<div class="language-ruby highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"> <a href="#n1" name="n1">1</a></span><span style="color:#777"># For every new Graph object</span>
<span class="line-numbers"> <a href="#n2" name="n2">2</a></span><span style="color:#777"># graph_segments is the hash we need to give, based on it, we get ` :nodes, :weights, :parents` while initializing a new Graph instance</span>
<span class="line-numbers"> <a href="#n3" name="n3">3</a></span><span style="color:#777"># Except for `:nodes` attribute, all the other attributes are implemented by hash.</span>
<span class="line-numbers"> <a href="#n4" name="n4">4</a></span>
<span class="line-numbers"> <strong><a href="#n5" name="n5">5</a></strong></span>
<span class="line-numbers"> <a href="#n6" name="n6">6</a></span><span style="color:#080;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">Graph</span>
<span class="line-numbers"> <a href="#n7" name="n7">7</a></span>  attr_accessor <span style="color:#A60">:nodes</span>, <span style="color:#A60">:graph_segments</span>, <span style="color:#A60">:weights</span>, <span style="color:#A60">:parents</span>
<span class="line-numbers"> <a href="#n8" name="n8">8</a></span>
<span class="line-numbers"> <a href="#n9" name="n9">9</a></span>  <span style="color:#080;font-weight:bold">def</span> <span style="color:#06B;font-weight:bold">initialize</span>(graph_segments)
<span class="line-numbers"><strong><a href="#n10" name="n10">10</a></strong></span>    <span style="color:#33B">@graph_segments</span> = graph_segments
<span class="line-numbers"><a href="#n11" name="n11">11</a></span>    <span style="color:#33B">@weights</span> = { }
<span class="line-numbers"><a href="#n12" name="n12">12</a></span>    <span style="color:#33B">@nodes</span> = graph_segments.keys
<span class="line-numbers"><a href="#n13" name="n13">13</a></span>    <span style="color:#33B">@nodes</span>.each { |node| <span style="color:#33B">@weights</span>[node] = <span style="color:#036;font-weight:bold">Float</span>::<span style="color:#036;font-weight:bold">INFINITY</span> }
<span class="line-numbers"><a href="#n14" name="n14">14</a></span>    <span style="color:#33B">@parents</span> = {}
<span class="line-numbers"><strong><a href="#n15" name="n15">15</a></strong></span>    <span style="color:#33B">@nodes</span>.each { |node| <span style="color:#33B">@parents</span>[node] = <span style="color:#069">nil</span> }
<span class="line-numbers"><a href="#n16" name="n16">16</a></span>  <span style="color:#080;font-weight:bold">end</span>
<span class="line-numbers"><a href="#n17" name="n17">17</a></span>
<span class="line-numbers"><a href="#n18" name="n18">18</a></span>
<span class="line-numbers"><a href="#n19" name="n19">19</a></span>  <span style="color:#080;font-weight:bold">def</span> <span style="color:#06B;font-weight:bold">calculate_weights_from</span>(source_vertex)
<span class="line-numbers"><strong><a href="#n20" name="n20">20</a></strong></span>      weights[source_vertex] = <span style="color:#00D">0</span>
<span class="line-numbers"><a href="#n21" name="n21">21</a></span>      current_proccessing_node = source_vertex
<span class="line-numbers"><a href="#n22" name="n22">22</a></span>      unproccessed_nodes = nodes
<span class="line-numbers"><a href="#n23" name="n23">23</a></span>
<span class="line-numbers"><a href="#n24" name="n24">24</a></span>      <span style="color:#080;font-weight:bold">while</span> unproccessed_nodes.include?(current_proccessing_node)
<span class="line-numbers"><strong><a href="#n25" name="n25">25</a></strong></span>        lowest_weight = weights[current_proccessing_node]
<span class="line-numbers"><a href="#n26" name="n26">26</a></span>        neighbors = graph_segments[current_proccessing_node].keys
<span class="line-numbers"><a href="#n27" name="n27">27</a></span>
<span class="line-numbers"><a href="#n28" name="n28">28</a></span>          neighbors.each <span style="color:#080;font-weight:bold">do</span> |neighbor|
<span class="line-numbers"><a href="#n29" name="n29">29</a></span>            new_weight = lowest_weight + graph_segments[current_proccessing_node][neighbor]
<span class="line-numbers"><strong><a href="#n30" name="n30">30</a></strong></span>            <span style="color:#080;font-weight:bold">if</span> new_weight &lt; weights[neighbor]
<span class="line-numbers"><a href="#n31" name="n31">31</a></span>              weights[neighbor] = new_weight
<span class="line-numbers"><a href="#n32" name="n32">32</a></span>              parents[neighbor] = current_proccessing_node
<span class="line-numbers"><a href="#n33" name="n33">33</a></span>            <span style="color:#080;font-weight:bold">end</span>
<span class="line-numbers"><a href="#n34" name="n34">34</a></span>          <span style="color:#080;font-weight:bold">end</span>
<span class="line-numbers"><strong><a href="#n35" name="n35">35</a></strong></span>
<span class="line-numbers"><a href="#n36" name="n36">36</a></span>        unproccessed_nodes -= [current_proccessing_node]
<span class="line-numbers"><a href="#n37" name="n37">37</a></span>        proccessed_nodes = nodes - unproccessed_nodes
<span class="line-numbers"><a href="#n38" name="n38">38</a></span>        lowest_weight = weights.values_at(*(unproccessed_nodes)).min
<span class="line-numbers"><a href="#n39" name="n39">39</a></span>        possible_lowest_weight_nodes = weights.select { |k, v| v == lowest_weight }
<span class="line-numbers"><strong><a href="#n40" name="n40">40</a></strong></span>          proccessed_nodes.each <span style="color:#080;font-weight:bold">do</span> |proccessed_node|
<span class="line-numbers"><a href="#n41" name="n41">41</a></span>            possible_lowest_weight_nodes.delete(proccessed_node)
<span class="line-numbers"><a href="#n42" name="n42">42</a></span>          <span style="color:#080;font-weight:bold">end</span>
<span class="line-numbers"><a href="#n43" name="n43">43</a></span>        current_proccessing_node = possible_lowest_weight_nodes.key(lowest_weight)
<span class="line-numbers"><a href="#n44" name="n44">44</a></span>      <span style="color:#080;font-weight:bold">end</span>
<span class="line-numbers"><strong><a href="#n45" name="n45">45</a></strong></span>
<span class="line-numbers"><a href="#n46" name="n46">46</a></span>      puts <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#b0b">\n</span><span style="color:#D20">Final updated weights from source_vertex is: </span><span style="color:#b0b">\n</span><span style="color:#D20"> </span><span style="background-color:hsla(0,0%,0%,0.07);color:black"><span style="font-weight:bold;color:#666">#{</span>weights<span style="font-weight:bold;color:#666">}</span></span><span style="color:#710">&quot;</span></span>
<span class="line-numbers"><a href="#n47" name="n47">47</a></span>      puts <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#b0b">\n</span><span style="color:#D20">Following the lowest weight path, every node's parent is: </span><span style="color:#b0b">\n</span><span style="color:#D20"> </span><span style="background-color:hsla(0,0%,0%,0.07);color:black"><span style="font-weight:bold;color:#666">#{</span>parents<span style="font-weight:bold;color:#666">}</span></span><span style="color:#D20"> </span><span style="color:#b0b">\n</span><span style="color:#710">&quot;</span></span>
<span class="line-numbers"><a href="#n48" name="n48">48</a></span>  <span style="color:#080;font-weight:bold">end</span>
<span class="line-numbers"><a href="#n49" name="n49">49</a></span>
<span class="line-numbers"><strong><a href="#n50" name="n50">50</a></strong></span><span style="color:#080;font-weight:bold">end</span>
<span class="line-numbers"><a href="#n51" name="n51">51</a></span>
<span class="line-numbers"><a href="#n52" name="n52">52</a></span>
<span class="line-numbers"><a href="#n53" name="n53">53</a></span>from_a = { <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">a</span><span style="color:#710">&quot;</span></span> =&gt; { <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">b</span><span style="color:#710">&quot;</span></span>=&gt;<span style="color:#00D">8</span>, <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">d</span><span style="color:#710">&quot;</span></span>=&gt;<span style="color:#00D">5</span>, <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">c</span><span style="color:#710">&quot;</span></span>=&gt;<span style="color:#00D">2</span> } }
<span class="line-numbers"><a href="#n54" name="n54">54</a></span>from_b = { <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">b</span><span style="color:#710">&quot;</span></span> =&gt; { <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">d</span><span style="color:#710">&quot;</span></span>=&gt;<span style="color:#00D">2</span>, <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">f</span><span style="color:#710">&quot;</span></span>=&gt;<span style="color:#00D">13</span> } }
<span class="line-numbers"><strong><a href="#n55" name="n55">55</a></strong></span>from_c = { <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">c</span><span style="color:#710">&quot;</span></span> =&gt; { <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">d</span><span style="color:#710">&quot;</span></span>=&gt;<span style="color:#00D">2</span>, <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">e</span><span style="color:#710">&quot;</span></span>=&gt;<span style="color:#00D">5</span> } }
<span class="line-numbers"><a href="#n56" name="n56">56</a></span>from_d = { <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">d</span><span style="color:#710">&quot;</span></span> =&gt; { <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">b</span><span style="color:#710">&quot;</span></span>=&gt;<span style="color:#00D">2</span>, <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">e</span><span style="color:#710">&quot;</span></span>=&gt;<span style="color:#00D">1</span>, <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">f</span><span style="color:#710">&quot;</span></span>=&gt;<span style="color:#00D">6</span>, <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">g</span><span style="color:#710">&quot;</span></span>=&gt;<span style="color:#00D">3</span> } }
<span class="line-numbers"><a href="#n57" name="n57">57</a></span>from_e = { <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">e</span><span style="color:#710">&quot;</span></span> =&gt; { <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">g</span><span style="color:#710">&quot;</span></span>=&gt;<span style="color:#00D">1</span> } }
<span class="line-numbers"><a href="#n58" name="n58">58</a></span>from_f = { <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">f</span><span style="color:#710">&quot;</span></span> =&gt; { <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">g</span><span style="color:#710">&quot;</span></span>=&gt;<span style="color:#00D">2</span>, <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">h</span><span style="color:#710">&quot;</span></span>=&gt;<span style="color:#00D">3</span> } }
<span class="line-numbers"><a href="#n59" name="n59">59</a></span>from_g = { <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">g</span><span style="color:#710">&quot;</span></span> =&gt; { <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">f</span><span style="color:#710">&quot;</span></span>=&gt;<span style="color:#00D">2</span>, <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">h</span><span style="color:#710">&quot;</span></span>=&gt;<span style="color:#00D">6</span> } }
<span class="line-numbers"><strong><a href="#n60" name="n60">60</a></strong></span>from_h = { <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">h</span><span style="color:#710">&quot;</span></span> =&gt; { <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">h</span><span style="color:#710">&quot;</span></span>=&gt;<span style="color:#00D">0</span> }}
<span class="line-numbers"><a href="#n61" name="n61">61</a></span>
<span class="line-numbers"><a href="#n62" name="n62">62</a></span>graph_segments = [from_a, from_b, from_c, from_d, from_e, from_f, from_g, from_h].reduce { |graph, hash|  graph.merge! hash }
<span class="line-numbers"><a href="#n63" name="n63">63</a></span>
<span class="line-numbers"><a href="#n64" name="n64">64</a></span>graph = <span style="color:#036;font-weight:bold">Graph</span>.new(graph_segments)
<span class="line-numbers"><strong><a href="#n65" name="n65">65</a></strong></span>graph.calculate_weights_from(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">a</span><span style="color:#710">&quot;</span></span>)
</pre></div>
</div>
</div>

<p>这里的结果和上面没有class的一样，这里并不一定要把 <code>a</code> 作为 souurce_vertex， 可以使用其他 vertex</p>

<p>比如 c: <code>graph.calculate_weights_from("c")</code></p>

<div class="language-ruby highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"><a href="#n1" name="n1">1</a></span><span style="color:#036;font-weight:bold">Final</span> updated weights from source_vertex <span style="color:#606">is</span>:
<span class="line-numbers"><a href="#n2" name="n2">2</a></span> {<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">a</span><span style="color:#710">&quot;</span></span>=&gt;<span style="color:#036;font-weight:bold">Infinity</span>, <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">b</span><span style="color:#710">&quot;</span></span>=&gt;<span style="color:#00D">4</span>, <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">c</span><span style="color:#710">&quot;</span></span>=&gt;<span style="color:#00D">0</span>, <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">d</span><span style="color:#710">&quot;</span></span>=&gt;<span style="color:#00D">2</span>, <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">e</span><span style="color:#710">&quot;</span></span>=&gt;<span style="color:#00D">3</span>, <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">f</span><span style="color:#710">&quot;</span></span>=&gt;<span style="color:#00D">6</span>, <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">g</span><span style="color:#710">&quot;</span></span>=&gt;<span style="color:#00D">4</span>, <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">h</span><span style="color:#710">&quot;</span></span>=&gt;<span style="color:#00D">9</span>}
<span class="line-numbers"><a href="#n3" name="n3">3</a></span>
<span class="line-numbers"><a href="#n4" name="n4">4</a></span><span style="color:#036;font-weight:bold">Following</span> the lowest weight path, every node<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">s parent is:</span></span>
<span class="line-numbers"><strong><a href="#n5" name="n5">5</a></strong></span><span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#D20"> {&quot;a&quot;=&gt;nil, &quot;b&quot;=&gt;&quot;d&quot;, &quot;c&quot;=&gt;nil, &quot;d&quot;=&gt;&quot;c&quot;, &quot;e&quot;=&gt;&quot;d&quot;, &quot;f&quot;=&gt;&quot;g&quot;, &quot;g&quot;=&gt;&quot;e&quot;, &quot;h&quot;=&gt;&quot;f&quot;}</span></span>
<span class="line-numbers"><a href="#n6" name="n6">6</a></span><span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#D20"></span></span></pre></div>
</div>
</div>

<p>注意这里某些点对应的是 Infinity, 这是因为用于计算的 graph 是 directed graph 就是有向的，这意味着从某些点出发是不能到达某些点的。在定义 graph_segments 的时候，实际就定义好了 edges 的方向。比如 c 节点当时是这样定义的</p>

<p><code>from_c = { "c" =&gt; { "d"=&gt;2, "e"=&gt;5 } }</code></p>

<p>那么c就只能往 d 或者 e 走， 而 d 和 e 相关的 edges 也是有方向的，这就导致从 c 出发是无法到达 a 的，所以距离是 INFINITY</p>

<p>同样在定义 h 节点时，他没有neighbors, 也就是只有 f 和 h 指向他，而他自己没有指向任何其他节点，所以如果你从 h 出发，那么除它本身对应的weight是0以外，其他节点应该都是 INFINITY</p>

<p><code>graph.calculate_weights_from("h")</code></p>

<div class="language-ruby highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"><a href="#n1" name="n1">1</a></span><span style="color:#036;font-weight:bold">Final</span> updated weights from source_vertex <span style="color:#606">is</span>:
<span class="line-numbers"><a href="#n2" name="n2">2</a></span> {<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">a</span><span style="color:#710">&quot;</span></span>=&gt;<span style="color:#036;font-weight:bold">Infinity</span>, <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">b</span><span style="color:#710">&quot;</span></span>=&gt;<span style="color:#036;font-weight:bold">Infinity</span>, <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">c</span><span style="color:#710">&quot;</span></span>=&gt;<span style="color:#036;font-weight:bold">Infinity</span>, <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">d</span><span style="color:#710">&quot;</span></span>=&gt;<span style="color:#036;font-weight:bold">Infinity</span>, <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">e</span><span style="color:#710">&quot;</span></span>=&gt;<span style="color:#036;font-weight:bold">Infinity</span>, <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">f</span><span style="color:#710">&quot;</span></span>=&gt;<span style="color:#036;font-weight:bold">Infinity</span>, <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">g</span><span style="color:#710">&quot;</span></span>=&gt;<span style="color:#036;font-weight:bold">Infinity</span>, <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">h</span><span style="color:#710">&quot;</span></span>=&gt;<span style="color:#00D">0</span>}
<span class="line-numbers"><a href="#n3" name="n3">3</a></span>
<span class="line-numbers"><a href="#n4" name="n4">4</a></span><span style="color:#036;font-weight:bold">Following</span> the lowest weight path, every node<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">s parent is:</span></span>
<span class="line-numbers"><strong><a href="#n5" name="n5">5</a></strong></span><span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#D20"> {&quot;a&quot;=&gt;nil, &quot;b&quot;=&gt;nil, &quot;c&quot;=&gt;nil, &quot;d&quot;=&gt;nil, &quot;e&quot;=&gt;nil, &quot;f&quot;=&gt;nil, &quot;g&quot;=&gt;nil, &quot;h&quot;=&gt;nil}</span></span>
<span class="line-numbers"><a href="#n6" name="n6">6</a></span><span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#D20"></span></span></pre></div>
</div>
</div>

<hr />

<h4 id="recap">Recap</h4>

<p>作为回顾，可以再看下 wikipedia 上Dijkstra’s algorithm 的 gif 图，他和breadth-first search的基本行为模式类似，都是逐层展开。</p>

<p><img src="https://s3-ap-southeast-1.amazonaws.com/image-for-articles/image-bucket-1/Dijkstra_Animation.gif" alt="" /></p>

<ul>
  <li>Breadth-first search is used to calculate the shortest path for an unweighted graph.   <br />
广度优先搜索只适用于 unweighted graph</li>
  <li>Dijkstra’s algorithm is used to calculate the shortest path for a weighted graph.   <br />
Dijkstra’s algorithm 可以用于 weighted graph 的计算</li>
  <li>Dijkstra’s algorithm works when all the weights are positive.    <br />
当所有edge的weight 是正数时，Dijkstra’s algorithm 可以很好的工作（负数状态其实不太会在现实中出现）</li>
</ul>

<hr />

<p>附：</p>

<p>一个将 graph 相关算法用 ruby 写出来的 git repo</p>

<p>https://github.com/brianstorti/ruby-graph-algorithms</p>

</div>

  </body>
</html>